[gd_scene load_steps=22 format=3 uid="uid://b6sllsho3j5d0"]

[ext_resource type="PackedScene" uid="uid://bqhi1muo3obss" path="res://scenes/characters/unit.tscn" id="1_3i8mp"]
[ext_resource type="Texture2D" uid="uid://dylf6bubhlan2" path="res://sprites/shadow.png" id="3_pwyi4"]
[ext_resource type="Texture2D" uid="uid://c418dki3gw0y7" path="res://sprites/selection.png" id="4_ctsox"]
[ext_resource type="Texture2D" uid="uid://bbkf2tlyficf6" path="res://sprites/skeleton_warrior/skellington_warrior_body.png" id="5_vjdtb"]
[ext_resource type="Texture2D" uid="uid://ymu8vxktg2t7" path="res://sprites/skeleton_warrior/skellington_warrior_shield.png" id="6_vtdhx"]
[ext_resource type="Texture2D" uid="uid://chk2x4f7c6xvb" path="res://sprites/skeleton_warrior/skellington_warrior_left_boot.png" id="7_c0tc4"]
[ext_resource type="Texture2D" uid="uid://dd80gild66mgj" path="res://sprites/skeleton_warrior/skellington_warrior_right_boot.png" id="8_i1bis"]
[ext_resource type="Texture2D" uid="uid://ceoj7ghhpw2mq" path="res://sprites/skeleton_warrior/skellington_warrior_sword.png" id="9_1lmvd"]
[ext_resource type="Texture2D" uid="uid://c5guqovle2c50" path="res://sprites/skeleton_warrior/skellington_warrior_head.png" id="10_ttf1s"]
[ext_resource type="PackedScene" uid="uid://dyst0xyeehbia" path="res://scenes/warrior_state_machine.tscn" id="11_ss8ps"]

[sub_resource type="GDScript" id="GDScript_4p8jh"]
script/source = "extends UnitParent

var selected: bool = false

#movement
var speed = 300
var move_target = Vector2.ZERO
var stop_distance = 30 #jak daleko ma sie zatrzymywac od swojego celu (state == moving)
const move_treshold = 0.5 #temporary, bedzie wymienione przy pathfindingu
var last_position = Vector2.ZERO #temporary, bedzie wymienione przy pathfindingu
var next_path_position
var can_navigate:bool = true
var follow_distance_idle:int = 400
var follow_distance_absolute:int = 1000
#combat
var damage = 20
var attack_target #ZAWSZE ALE TO ZAWSZE PRZY ATTACK_TARGET UZYWAJCIE .get_ref()
var possible_targets = [] #jednostki ktore wejda w VisionArea
const attack_range = 100
const vision_range = 500

var mouse_hovering:bool = false

var state_machine
@onready var health_bar: ProgressBar = $HealthBar 
@onready var damage_bar: ProgressBar = $DamageBar
@onready var navigation_agent_2d: NavigationAgent2D = $NavigationAgent2D
@onready var unstick_timer: Timer = $Timers/UnstickTimer

func _ready() -> void:
	unit_hud_order = 3
	icon_texture = \"res://sprites/skeleton mage icon.png\"
	max_health  = 60
	health = max_health
	health_bar.max_value = max_health
	health_bar.value = max_health
	health_bar.visible = false
	
	damage_bar.max_value = max_health
	damage_bar.value = max_health
	damage_bar.visible = false
	
	bar_style.bg_color = Color(\"10bf00ff\")
	bar_style.border_width_left = 2
	bar_style.border_width_top = 2
	bar_style.border_width_bottom = 2
	bar_style.border_color = Color(0.0, 0.0, 0.0, 1.0)
	health_bar.add_theme_stylebox_override(\"fill\", bar_style)

	navigation_agent_2d.max_speed = speed
	move_target = global_position
	motion_mode = CharacterBody2D.MOTION_MODE_FLOATING
	state_machine = $WarriorStateMachine
	$VisionArea/CollisionShape2D.disabled = true
	
	navigation_agent_2d.velocity_computed.connect(_on_navigation_agent_2d_velocity_computed)
	$ClickArea.mouse_entered.connect(_on_click_area_mouse_entered)
	$ClickArea.mouse_exited.connect(_on_click_area_mouse_exited)
	$Timers/NavigationTimer.timeout.connect(_on_navigation_timer_timeout)
	
func _physics_process(_delta: float) -> void:
	seek_enemies()
	follow_player()
	print(state_machine.state)
#INPUT ===============================================================================
func handle_inputs(event):
	if state_machine.state == state_machine.states.dying:
		return #jeśli jednostka umiera to nie możemy jej wydać rozkazów
	match event:
		\"left_click\":
			if !state_machine.command_key == state_machine.command_keys.ATTACK_MOVE:
				return
			state_machine.command_key = state_machine.command_keys.NONE
			state_machine.command = state_machine.commands.ATTACK_MOVE
			move_target = get_global_mouse_position()
			state_machine.set_state(state_machine.states.moving)
		\"right_click\":
			state_machine.command = state_machine.commands.MOVE
			state_machine.command_key = state_machine.command_keys.NONE
			move_target = get_global_mouse_position()
			state_machine.set_state(state_machine.states.moving)
		\"attack_move\":
			state_machine.command_key = state_machine.command_keys.ATTACK_MOVE
		\"stop\":
			state_machine.command = state_machine.commands.NONE
			state_machine.command_key = state_machine.command_keys.NONE
			state_machine.set_state(state_machine.states.idle)
		\"hold\":
			state_machine.command = state_machine.commands.HOLD
			state_machine.command_key = state_machine.command_keys.NONE
			state_machine.set_state(state_machine.states.idle)

#DO NOT TOUCH, MOZE SIE PRZYDA W PRZYSZLOSCI
#func _TEMPunhandled_input(event: InputEvent) -> void:
	#if state_machine.state == state_machine.states.dying:
		#return #jeśli jednostka umiera to nie możemy jej wydać rozkazów
	#if !selected:
		#return #sprawdzamy czy jednostka jest selectowana
	#if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_RIGHT:
		#if event.is_released(): #kiedy right clickujemy każemy jednostce iść do punktu na ziemi
			#state_machine.command = state_machine.commands.MOVE
			#state_machine.command_key = state_machine.command_keys.NONE
			#move_target = get_global_mouse_position()
			#state_machine.set_state(state_machine.states.moving)
	#elif event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		#if !state_machine.command_key == state_machine.command_keys.ATTACK_MOVE:
			#return
		#if event.is_released():
			#state_machine.command_key = state_machine.command_keys.NONE
			#state_machine.command = state_machine.commands.ATTACK_MOVE
			#move_target = get_global_mouse_position()
			#state_machine.set_state(state_machine.states.moving)
	#elif event.is_action_pressed(\"attack_move\"): #domyslny hotkey - Z
		#state_machine.command_key = state_machine.command_keys.ATTACK_MOVE
	#elif event.is_action_pressed(\"stop\"): #domyslny hotkey - X
		#state_machine.command = state_machine.commands.NONE
		#state_machine.command_key = state_machine.command_keys.NONE
		#state_machine.set_state(state_machine.states.idle)
	#elif event.is_action_pressed(\"hold\"): #domyslny hotkey - C
		#state_machine.command = state_machine.commands.HOLD
		#state_machine.command_key = state_machine.command_keys.NONE
		#state_machine.set_state(state_machine.states.idle)
#MOVEMENT ===============================================================================
func _move_to_target(_delta,target_position):
	velocity = global_position.direction_to(target_position) * speed
	move_and_slide()

func move_to_target(_delta,target_position): #CLOSE RANGE MOVEMENT
	if !get_slide_collision_count() and unstick_timer.is_stopped():
		navigation_agent_2d.target_position = target_position
		var new_velocity = global_position.direction_to(target_position) * speed
		navigation_agent_2d.set_velocity(new_velocity)
	if get_slide_collision_count() and unstick_timer.is_stopped():
		unstick_timer.start() # JEŚLI WYKRYJE KOLIZJE NA SEKUNDE DOSTAJE A* MOVEMENT
	if !unstick_timer.is_stopped():
		if can_navigate:
			calculate_new_path(target_position) #A* MOVEMENT
			var new_velocity = global_position.direction_to(next_path_position) * speed
			navigation_agent_2d.set_velocity(new_velocity)
			can_navigate = false
			$Timers/NavigationTimer.start()
	move_and_slide()

func navigate_to_target(_delta,target_position): #A* MOVEMENT
	if can_navigate:
		calculate_new_path(target_position)
		can_navigate = false
		$Timers/NavigationTimer.start()
	var new_velocity = global_position.direction_to(next_path_position) * speed
	navigation_agent_2d.set_velocity(new_velocity)
	move_and_slide()

func _on_navigation_agent_2d_velocity_computed(safe_velocity: Vector2) -> void:
	velocity = safe_velocity

func calculate_new_path(target_position):
	navigation_agent_2d.target_position = target_position
	next_path_position = navigation_agent_2d.get_next_path_position()

func _on_navigation_timer_timeout() -> void:
	can_navigate = true

func follow_player() -> void:
	if global_position.distance_to(Globals.player_position) > follow_distance_absolute:
		state_machine.command = state_machine.commands.NONE
		move_target = (Globals.player_position - global_position.direction_to(Globals.player_position) * 100)
		state_machine.state = state_machine.states.moving
		return
	if state_machine.state == state_machine.states.idle: #powrót nawet podczas walki
		if global_position.distance_to(Globals.player_position) > follow_distance_idle:
			state_machine.command = state_machine.commands.FOLLOW_PLAYER
			move_target = (Globals.player_position - global_position.direction_to(Globals.player_position) * 100)
			state_machine.state = state_machine.states.moving
	elif state_machine.command == state_machine.commands.FOLLOW_PLAYER:
		move_target = (Globals.player_position - global_position.direction_to(Globals.player_position) * 100)

#COMBAT ===============================================================================
func hit(damage_taken, _damage_source) -> bool:
	health_bar.visible = true
	damage_bar.visible = true
	
	health -= damage_taken
	health_bar.value = health
	
	var tween = create_tween()
	tween.tween_property(damage_bar, \"value\", health, 0.5) 
	tween.set_trans(Tween.TRANS_SINE)
	tween.set_ease(Tween.EASE_OUT)
	if health <= 0: #hp poniżej 0 - umieranie
		Globals.unit_died.emit(self)
		health_bar.visible = false
		damage_bar.visible = false
		state_machine.call_deferred(\"set_state\", state_machine.states.dying) #tu i niżej musimy zmienić na call_deferred(), i don't make the rules
		$CollisionShape2D.call_deferred(\"set_deferred\", \"disabled\", true) #disablujemy collision zeby przeciwnicy nie atakowali martwych unitów
		return false #returnuje false dla przeciwnika, który sprawdza czy jednostka wciąż żyje
	else:
		return true #jednostka ma ponad 0hp więc wciąż żyje

func attack():
	if attack_target.get_ref(): #jeśli nasz cel wciąż istnieje:
		if attack_target.get_ref().hit(damage, self): #wysyła hit do celu
			pass #jeśli cel zwrócił true - czyli żyje - kontynuuj atakowanie
		else:
			state_machine.set_state(state_machine.states.idle) #cel zmarł - przejdź do stanu idle

func seek_enemies():
	for unit in possible_targets:
		if unit == null:
			possible_targets.erase(unit)
	for enemy in get_tree().get_nodes_in_group(\"Unit\"):
		if enemy not in get_tree().get_nodes_in_group(\"Allied\"):
			if global_position.distance_to(enemy.global_position) > vision_range:
				if possible_targets.has(enemy):
					possible_targets.erase(enemy)
			else:
				if !possible_targets.has(enemy):
					possible_targets.append(enemy)

#func _on_vision_area_body_entered(body: Node2D) -> void:
	#if body.is_in_group(\"Unit\"): #sprawdza czy jednostka, która weszła w vision range to valid target
		#if not body.is_in_group(\"Allied\"): #Sprawdza czy nie jest sojusznikiem
			#possible_targets.append(body) #dodajemy target do listy
#
#func _on_vision_area_body_exited(body: Node2D) -> void:
	#if possible_targets.has(body): #jednostka z listy targetów wyszła z wizji
		#possible_targets.erase(body)

#to jest funkcja do sortowania, jesli target a jest blizej targeta b to jest przesuwany blizej
#pozycji 0 w arrayu; a pozycja 0 w arrayu possible_target to najblizszy cel :D
func _compare_distance(target_a, target_b):
	if target_a and target_b:
		if global_position.distance_to(target_a.global_position) < global_position.distance_to(target_b.global_position):
			return true
		else:
			return false

func closest_enemy(): #sprawdza, który cel jest najbliżej
	if possible_targets.size() > 0:
		if possible_targets.size() > 1:
			possible_targets.sort_custom(_compare_distance) # <- to powyższy algorytm sortujący
		return possible_targets[0]
	else:
		return null

func attack_target_within_attack_range(): #sprawdź czy attack_target znajduje się w attack_range
	if attack_target.get_ref() and attack_target.get_ref().global_position.distance_to(global_position) < \\
	attack_range:
		return attack_target.get_ref() #jeśli jest to go zwróć
	else:
		return null

func closest_enemy_within_attack_range():
	if closest_enemy() != null and closest_enemy().global_position.distance_to(global_position) < \\
	attack_range:
		return closest_enemy()
	else:
		return null
#SELECTING ===============================================================================
#dodawanie i usuwanie z grupy Selected, wywoływane albo w scenie unit selector w levelu
#albo poprzez left click
func select() -> void:
	add_to_group(\"Selected\")
	selected = true
	$Selected.visible = true

func deselect() -> void:
	if !state_machine.command_key == state_machine.command_keys.ATTACK_MOVE:
		remove_from_group(\"Selected\")
		selected = false
		$Selected.visible = false

#do sprawdzania czy znajduje się w selection boxie w unit selectorze w scenie Level
func is_in_selection_box(select_box: Rect2):
	return select_box.has_point(global_position)

#Selectowanie jednostki left clickiem na nią
func _on_click_area_input_event(_viewport: Node, event: InputEvent, _shape_idx: int) -> void:
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		if state_machine.command_key == state_machine.command_keys.ATTACK_MOVE:
			return #jesli chcemy zrobic attack move to nie selectujemy jednostki left clickowanej
		if event.is_released:
			select()

#sprawdzamy czy myszka znajduje się w Area2D naszego ClickArea
func _on_click_area_mouse_entered() -> void:
	mouse_hovering = true
	#male testy do feedbacku dla gracza
	$Highlighted.visible = true
	Globals.add_overlapping_allies()

#sprawdzamy czy myszka znajduje się poza Area2D naszego ClickArea
func _on_click_area_mouse_exited() -> void:
	mouse_hovering = false
	#male testy do feedbacku dla gracza
	$Highlighted.visible = false
	Globals.remove_overlapping_allies()
"

[sub_resource type="GDScript" id="GDScript_bluo0"]
script/source = "extends Sprite2D
"

[sub_resource type="CircleShape2D" id="CircleShape2D_bluo0"]
radius = 24.083189

[sub_resource type="CircleShape2D" id="CircleShape2D_e0k25"]
radius = 325.04153

[sub_resource type="CapsuleShape2D" id="CapsuleShape2D_w5s2j"]
radius = 43.0
height = 118.0

[sub_resource type="Animation" id="Animation_kwpy4"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D/Body:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 0)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("Sprite2D/Head:position")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 10)]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("Sprite2D/Sword:position")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 20)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("Sprite2D/Shield:position")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 0)]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("Sprite2D/Legs/LeftLeg:position")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 0)]
}
tracks/5/type = "value"
tracks/5/imported = false
tracks/5/enabled = true
tracks/5/path = NodePath("Sprite2D/Legs/RightLeg:position")
tracks/5/interp = 1
tracks/5/loop_wrap = true
tracks/5/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 0)]
}
tracks/6/type = "value"
tracks/6/imported = false
tracks/6/enabled = true
tracks/6/path = NodePath("Sprite2D/Sword:rotation")
tracks/6/interp = 1
tracks/6/loop_wrap = true
tracks/6/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [0.0]
}
tracks/7/type = "value"
tracks/7/imported = false
tracks/7/enabled = true
tracks/7/path = NodePath("Sprite2D/Body:rotation")
tracks/7/interp = 1
tracks/7/loop_wrap = true
tracks/7/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [0.0]
}
tracks/8/type = "value"
tracks/8/imported = false
tracks/8/enabled = true
tracks/8/path = NodePath("Sprite2D/Head:rotation")
tracks/8/interp = 1
tracks/8/loop_wrap = true
tracks/8/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [0.0]
}

[sub_resource type="Animation" id="Animation_e2rn1"]
resource_name = "attack"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D/Sword:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.3667, 0.5, 0.6666667, 0.83000004),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, -60), Vector2(-60, 30), Vector2(0, -20), Vector2(0, 0)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("Sprite2D/Sword:rotation")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0, 0.36, 0.5, 0.6666667, 0.83000004),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1),
"update": 0,
"values": [0.0, 0.83775806, -1.1187560505283656, 0.3490658503988659, 0.0]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("Sprite2D/Legs/LeftLeg:position")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0, 0.36, 0.5),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, -20), Vector2(0, 0)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("Sprite2D/Body:rotation")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0, 0.36, 0.5, 0.7),
"transitions": PackedFloat32Array(1, 1, 1, 1),
"update": 0,
"values": [0.0, 0.08726646, -0.08726646, 0.0]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("Sprite2D/Head:rotation")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0, 0.42666668, 0.56666666, 0.7),
"transitions": PackedFloat32Array(1, 1, 1, 1),
"update": 0,
"values": [0.0, 0.08726646, -0.08726646, 0.0]
}
tracks/5/type = "value"
tracks/5/imported = false
tracks/5/enabled = true
tracks/5/path = NodePath("Sprite2D/Shield:position")
tracks/5/interp = 1
tracks/5/loop_wrap = true
tracks/5/keys = {
"times": PackedFloat32Array(0, 0.36666667, 0.5, 0.7),
"transitions": PackedFloat32Array(1, 1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, 15), Vector2(0, -15), Vector2(0, 0)]
}
tracks/6/type = "method"
tracks/6/imported = false
tracks/6/enabled = true
tracks/6/path = NodePath(".")
tracks/6/interp = 1
tracks/6/loop_wrap = true
tracks/6/keys = {
"times": PackedFloat32Array(0.5),
"transitions": PackedFloat32Array(1),
"values": [{
"args": [],
"method": &"attack"
}]
}

[sub_resource type="Animation" id="Animation_p5k3i"]
resource_name = "dying"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D/Head:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.96666664),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, -120)]
}

[sub_resource type="Animation" id="Animation_hnk33"]
resource_name = "idle"
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D/Body:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.51, 1),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, 10), Vector2(0, 0)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("Sprite2D/Head:position")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0.1, 0.6, 1),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, 10), Vector2(0, 2)]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("Sprite2D/Sword:position")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0.1, 0.6, 1),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, 20), Vector2(0, 4)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("Sprite2D/Shield:position")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0.1, 0.6, 1),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, 10), Vector2(0, 2)]
}

[sub_resource type="Animation" id="Animation_mfyro"]
resource_name = "walk"
length = 1.5
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D/Body:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.51, 1),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, 10), Vector2(0, 0)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("Sprite2D/Head:position")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0.15833336, 0.53333336, 0.90833336, 1.2833333),
"transitions": PackedFloat32Array(1, 1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, 20), Vector2(0, 0), Vector2(0, 20)]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("Sprite2D/Sword:position")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0.1, 0.465, 0.84, 1.215),
"transitions": PackedFloat32Array(1, 1, 1, 1),
"update": 0,
"values": [Vector2(-10, 0), Vector2(0, 20), Vector2(10, 0), Vector2(0, 20)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("Sprite2D/Shield:position")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0.025000013, 0.4, 0.77500004, 1.1500001),
"transitions": PackedFloat32Array(1, 1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, 20), Vector2(0, 0), Vector2(0, 20)]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("Sprite2D/Legs/LeftLeg:position")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0, 0.25, 0.5, 0.75, 1, 1.25),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1),
"update": 0,
"values": [Vector2(0, -15), Vector2(0, 0), Vector2(0, -15), Vector2(0, 0), Vector2(0, -15), Vector2(0, 0)]
}
tracks/5/type = "value"
tracks/5/imported = false
tracks/5/enabled = true
tracks/5/path = NodePath("Sprite2D/Legs/RightLeg:position")
tracks/5/interp = 1
tracks/5/loop_wrap = true
tracks/5/keys = {
"times": PackedFloat32Array(0, 0.25, 0.5, 0.75, 1, 1.25),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1),
"update": 0,
"values": [Vector2(0, 0), Vector2(0, -15), Vector2(0, 0), Vector2(0, -15), Vector2(0, 0), Vector2(0, -15)]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_cm8ef"]
_data = {
&"RESET": SubResource("Animation_kwpy4"),
&"attack": SubResource("Animation_e2rn1"),
&"dying": SubResource("Animation_p5k3i"),
&"idle": SubResource("Animation_hnk33"),
&"walk": SubResource("Animation_mfyro")
}

[node name="SkeletonMager" groups=["Allied", "Selectable"] instance=ExtResource("1_3i8mp")]
collision_layer = 4
collision_mask = 11
script = SubResource("GDScript_4p8jh")

[node name="Shadow" type="Sprite2D" parent="." index="0"]
modulate = Color(1, 1, 1, 0.5529412)
position = Vector2(0, 33)
scale = Vector2(0.092, 0.092)
texture = ExtResource("3_pwyi4")

[node name="Highlighted" type="Sprite2D" parent="." index="1"]
visible = false
modulate = Color(1, 1, 1, 0.4509804)
z_index = -1
position = Vector2(0, 37)
scale = Vector2(0.14781019, 0.14781019)
texture = ExtResource("4_ctsox")

[node name="Selected" type="Sprite2D" parent="." index="2"]
visible = false
z_index = -1
position = Vector2(0, 37)
scale = Vector2(0.14781019, 0.14781019)
texture = ExtResource("4_ctsox")

[node name="Sprite2D" parent="." index="3"]
position = Vector2(0, -11)
scale = Vector2(0.15, 0.15)
script = SubResource("GDScript_bluo0")

[node name="Body" type="Sprite2D" parent="Sprite2D" index="0"]
texture = ExtResource("5_vjdtb")

[node name="Shield" type="Sprite2D" parent="Sprite2D" index="1"]
texture = ExtResource("6_vtdhx")

[node name="Legs" type="Sprite2D" parent="Sprite2D" index="2"]

[node name="LeftLeg" type="Sprite2D" parent="Sprite2D/Legs" index="0"]
texture = ExtResource("7_c0tc4")

[node name="RightLeg" type="Sprite2D" parent="Sprite2D/Legs" index="1"]
texture = ExtResource("8_i1bis")

[node name="Sword" type="Sprite2D" parent="Sprite2D" index="3"]
position = Vector2(0, 20)
texture = ExtResource("9_1lmvd")

[node name="Head" type="Sprite2D" parent="Sprite2D" index="4"]
position = Vector2(0, 10)
scale = Vector2(0.99999994, 0.99999994)
texture = ExtResource("10_ttf1s")

[node name="CollisionShape2D" parent="." index="4"]
position = Vector2(0, 14)
shape = SubResource("CircleShape2D_bluo0")

[node name="VisionArea" type="Area2D" parent="." index="5"]
collision_layer = 16
collision_mask = 6

[node name="CollisionShape2D" type="CollisionShape2D" parent="VisionArea" index="0"]
shape = SubResource("CircleShape2D_e0k25")

[node name="ClickArea" parent="." index="6"]
collision_layer = 16
collision_mask = 0

[node name="CollisionShape2D" parent="ClickArea" index="0"]
position = Vector2(0, -15)
shape = SubResource("CapsuleShape2D_w5s2j")

[node name="DamageBar" parent="." index="7"]
offset_left = -25.0
offset_top = -69.0
offset_right = 25.0
offset_bottom = -61.0

[node name="Timers" type="Node" parent="." index="8"]

[node name="MoveTimer" type="Timer" parent="Timers" index="0"]

[node name="NavigationTimer" type="Timer" parent="Timers" index="1"]
wait_time = 0.05
one_shot = true

[node name="UnstickTimer" type="Timer" parent="Timers" index="2"]
one_shot = true

[node name="WarriorStateMachine" parent="." index="9" instance=ExtResource("11_ss8ps")]

[node name="AnimationPlayer" type="AnimationPlayer" parent="." index="10"]
libraries = {
&"": SubResource("AnimationLibrary_cm8ef")
}
autoplay = "idle"
blend_times = [&"attack", &"idle", 0.5, &"attack", &"walk", 0.5, &"idle", &"attack", 0.5, &"idle", &"walk", 0.5, &"walk", &"attack", 0.5, &"walk", &"idle", 0.5]

[node name="HealthBar" parent="." index="11"]
offset_left = -25.0
offset_top = -69.0
offset_right = 25.0
offset_bottom = -61.0

[node name="NavigationAgent2D" type="NavigationAgent2D" parent="." index="12"]
path_max_distance = 200.0
avoidance_enabled = true
radius = 20.0
neighbor_distance = 100.0

[connection signal="input_event" from="ClickArea" to="." method="_on_click_area_input_event"]
[connection signal="timeout" from="Timers/MoveTimer" to="WarriorStateMachine" method="_on_move_timer_timeout"]
